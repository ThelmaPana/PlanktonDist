---
title: "Analyze intertaxonomic distances."
author: "Thelma Pana√Øotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| cache: false
source("utils.R")
```

## Read saved distances

```{r load}
## Inter distances
# list processed files
processed <- list.files("data", pattern = "05\\.", full.names = TRUE)

# load data
res <- sapply(processed, function(x) mget(load(x)), simplify = TRUE)

# get summary data (1st line)
df_inter <- res[1,] %>% bind_rows()
# get distances (2nd line)
df_inter_dist <- res[2,] %>% bind_rows()

## Null distances
load("data/02a.f_val_dist.Rdata")
load("data/02b.rq_coef.Rdata")

## Apply log transformation for plotting
f_val_dist <- f_val_dist %>% 
  mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

df_inter <- df_inter %>% 
    mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

# Drop colonial collodaria, pb with segmentation
df_inter <- df_inter %>% filter(!str_detect(pair, "Collodaria_colonial"))

# Detect points above the polygon
df_inter <- df_inter %>% 
  mutate(above = log_test_stat > log_n_dist * (rq_coef %>% filter(tau == 0.95) %>% pull(slope)) + (rq_coef %>% filter(tau == 0.95) %>% pull(intercept)))
```

## Compute mean per pair

Distances were computed for pairs A-B and B-A, compute the average between these.

```{r pair_mean}
# Generate unsorted pair
df_inter <- df_inter %>% 
  separate_wider_delim(pair, delim = " - ", names = c("p1", "p2"), cols_remove = FALSE) %>% 
  mutate(
    pair_unsrt = ifelse(
      p1 < p2,
      paste(p1, p2, sep = " - "),
      paste(p2, p1, sep = " - ")
    ), .after = pair
  )

# Compute average of stats per pair
df_inter <- df_inter %>% 
  select(pair = pair_unsrt, n_obj:log_test_stat) %>% 
  group_by(pair) %>% 
  summarise_if(is.numeric, mean) %>% 
  mutate(above = log_test_stat > log_n_dist * (rq_coef %>% filter(tau == 0.95) %>% pull(slope)) + (rq_coef %>% filter(tau == 0.95) %>% pull(intercept)))
```

## Analyse Kuiper statistic

Plot test stat VS number of computed distances in a log-transformed space.

```{r plot}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 9
## Generate data to plot a ribbon between the regression lines
# limits for n_dist
lim_dist <- c(
  floor_dec(min(df_inter$n_dist), level = -(nchar(paste(min(df_inter$n_dist))) - 1)),
  ceiling_dec(max(df_inter$n_dist), level = -(nchar(paste(max(df_inter$n_dist))) - 1))
)

# Generate ribbon
rib_data <- tibble(n_dist = lim_dist) %>% 
  mutate(
    # apply log-transformation
    log_n_dist = log10(n_dist),
    # compute estimated kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.95) %>% pull(intercept)
  ) %>% 
  # reformat and reorder to plot a polygon
  pivot_longer(ymin:ymax, values_to = "y") %>% 
  mutate(order = c(1, 2, 4, 3)) %>% 
  arrange(order)

# Reorder pairs
df_inter <- df_inter %>% 
  arrange(pair) %>% 
  filter(n_dist > 100) %>% 
  mutate(pair = fct_inorder(pair))

# Prepare colours and shapes
df_inter_above <- df_inter %>% 
  filter(above) %>% 
  mutate(
    colour = as.character(paletteer_d(`"khroma::discreterainbow"`, n = 27)),
    shape = rep(21:25, 6)[1:27]
  )

## Plot results
ggplot() +
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray") +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter %>% filter(above), aes(x = log_n_dist, y = log_test_stat,  colour = pair, shape = pair, fill = pair)) +
  geom_point(data = df_inter %>% filter(!above), aes(x = log_n_dist, y = log_test_stat), colour = "grey") +
  scale_fill_manual(values = df_inter_above$colour) +
  scale_colour_manual(values = df_inter_above$colour) +
  scale_shape_manual(values = df_inter_above$shape) +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic", colour = "Pair", fill = "Pair", shape = "Pair") +
  theme(legend.position = "bottom", legend.direction ="vertical")
```

Count organisms with non random distributions.

```{r count_orga}
df_inter %>% 
  filter(above) %>% 
  select(pair) %>% 
  separate_wider_delim(pair, delim = " - ", names = c("t1", "t2")) %>% 
  pivot_longer(t1:t2, values_to = "taxon") %>% 
  select(taxon) %>% 
  count(taxon) %>% 
  arrange(n) %>% 
  mutate(taxon = fct_inorder(taxon)) %>% 
  ggplot() +
  geom_col(aes(x = taxon , y= n)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  labs(x = "Taxon", y = "N non random")
```

Does potential interections only affect the same taxa as in intra-taxonomic distances?

```{r inter_vs_intra}
df_inter %>% 
  filter(above) %>% 
  select(pair) %>% 
  separate_wider_delim(pair, delim = " - ", names = c("t1", "t2")) %>% 
  mutate(
    t1_intra = ifelse(t1 %in% c("Acantharea", "Cop_small", "Cop_Calanoida", "Cop_other"), TRUE, FALSE),
    t2_intra = ifelse(t2 %in% c("Acantharea", "Cop_small", "Cop_Calanoida", "Cop_other"), TRUE, FALSE),
    other_taxon = t1_intra | t2_intra
  ) %>% 
  filter(!other_taxon)
```

There is one pair that does not involve the taxa detected is intra-taxonomic distances analysis.

Plot distributions of those above the polygon.

```{r plot_dist}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 6
df_inter_dist %>% 
  left_join(df_inter, by = join_by(pair)) %>% 
  filter(above) %>% 
  pivot_longer(dist:dist_rand) %>% 
  mutate(value = value * 51 / 10000) %>% # from pixel to cm
  ggplot() + 
  geom_density(aes(x = value, colour = name), linewidth = 0.3) +
  scale_colour_manual(
    values = c("dist_rand" = "grey20", "dist" = "red"),
    labels = c("plankton", "null")
    ) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type") +
  facet_wrap(~pair, scales = "free")
```

Plot ECDF of those above the polygon.

```{r plot_ecdf}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 6
df_inter_dist %>% 
  left_join(df_inter, by = join_by(pair)) %>% 
  filter(above) %>% 
  pivot_longer(dist:dist_rand) %>% 
  mutate(value = value * 51 / 10000) %>% # from pixel to cm
  ggplot() + 
  stat_ecdf(aes(x = value, colour = name), linewidth = 0.3) +
  scale_colour_manual(
    values = c("dist_rand" = "grey20", "dist" = "red"),
    labels = c("plankton", "null")
    ) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type") +
  facet_wrap(~pair, scales = "free")
```

Plot 4 of them.

```{r plot_subset}
pair_to_plot <- df_inter %>% 
  filter(above) %>% 
  arrange(desc(n_dist)) %>% 
  slice_head(n = 4) %>% 
  pull(pair)

df_inter_dist %>% 
  left_join(df_inter, by = join_by(pair)) %>% 
  filter(above) %>% 
  filter(pair %in% pair_to_plot) %>% 
  pivot_longer(dist:dist_rand) %>% 
  mutate(value = value * 51 / 10000) %>% # from pixel to cm
  ggplot() + 
  geom_density(aes(x = value, colour = name), linewidth = 0.3) +
  scale_colour_manual(
    values = c("dist_rand" = "grey20", "dist" = "red"),
    labels = c("plankton", "null")
    ) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type") +
  facet_wrap(~pair, scales = "free")
```

## Interaction strength & confidence

```{r z_score}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 5
df_inter_scores <- df_inter %>% 
  mutate(
    # compute estimated mean, 5th and 95th percentiles kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymean = rq_coef %>% filter(tau == "mean") %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == "mean") %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.95) %>% pull(intercept),
    # compute sigma
    sigma = (ymax - ymin) / (2 * 1.645),
    # compute z-score
    z_score = (log_test_stat - ymean)/sigma
  )

ggplot() +
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray", outlier.shape = NA) +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter_scores %>% filter(above), aes(x = log_n_dist, y = log_test_stat, colour = z_score)) +
  scale_colour_viridis_c() +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistis", colour = "Z-score") 
```

Plot Z-score VS Kuiper statistic.

```{r plot_z}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 9
df_inter_scores %>% 
  filter(above) %>% 
  ggplot() + 
  geom_point(aes(x = test_stat, y = z_score, colour = pair, fill = pair, shape = pair)) +
  scale_colour_manual(values = df_inter_above$colour) +
  scale_fill_manual(values = df_inter_above$colour) +
  scale_shape_manual(values = df_inter_above$shape) +
  labs(x = "Kuiper statistic", y = "Z-score", colour = "Pair", fill = "Pair", shape = "Pair") +
  theme(legend.position = "bottom", legend.direction = "vertical") +
  expand_limits(x = 0, y = 0)
```

## Save

Save Z-score and Kuiper stat.

```{r save}
save(df_inter_scores, file = "data/05b.df_inter_scores.Rdata")
```
