---
title: "Analyze intertaxonomic distances, using small distances only."
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
```

## Load data

```{r read}
#| cache.lazy: false
load("data/02a.f_val_dist_small.Rdata")
load("data/02b.rq_coef_small.Rdata")

## Inter distances
# list processed files
processed <- list.files("data", pattern = "05\\.", full.names = TRUE)

# load data
res <- sapply(processed, function(x) mget(load(x)), simplify = TRUE)

# get summary data (1st line)
df_inter <- res[1,] %>% bind_rows()
# get distances (2nd line)
df_inter_dist <- res[2,] %>% bind_rows()

## Drop colonial Collodaria because of segmentation artifact
df_inter <- df_inter %>% filter(!str_detect(pair, "Collodaria_colonial"))
df_inter_dist <- df_inter_dist %>% filter(!str_detect(pair, "Collodaria_colonial"))
```

## Process data

### Null distances

```{r prep_null}
# Apply log transformation for plotting
f_val_dist <- f_val_dist %>% 
  mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

## Generate data to plot a ribbon between the regression lines
# limits for n_dist
lim_dist <- c(50, 2e9)
# Generate ribbon
rib_data <- tibble(n_dist = lim_dist) %>% 
  mutate(
    # apply log-transformation
    log_n_dist = log10(n_dist),
    # compute estimated kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.95) %>% pull(intercept)
  ) %>% 
  # reformat and reorder to plot a polygon
  pivot_longer(ymin:ymax, values_to = "y") %>% 
  mutate(order = c(1, 2, 4, 3)) %>% 
  arrange(order)
```

### Plankton distances

### Kuiper test on small distances

We need to filter distances to keep only the small distances, and perform the Kuiper test using these filtered distances.

```{r filter_dist}
# Keep only small distances
#df_inter_dist_small <- df_inter_dist %>% 
#  pivot_longer(dist:dist_rand) %>% 
#  mutate(value = value * 51 / 10000) %>% # from pixel to cm
#  filter(value < dist_thr_cm)

df_inter_dist_small <- df_inter_dist %>%
  pivot_longer(dist:dist_rand) %>% 
  # drop missing values, these were introduced to reach a storage size of 10000
  drop_na() %>% 
  mutate(value = value * 51 / 10000) %>% # convert from px to cm
  # separate pair into taxon_1 and taxon_2
  separate_wider_delim(pair, delim = " - ", names = c("taxon_1", "taxon_2"), cols_remove = FALSE) %>% 
  # join with distance threshold of taxon_1
  left_join(plankton_esd %>% rename_with(~paste0(.x, "_1")), by = join_by(taxon_1)) %>% 
  # join with distance threshold of taxon_2
  left_join(plankton_esd %>% rename_with(~paste0(.x, "_2")), by = join_by(taxon_2)) %>% 
  # keep the largest threshold
  mutate(dist_thr = max(dist_thr_1, dist_thr_2)) %>% 
  # keep only distances below the threshold
  filter(value < dist_thr) %>% 
  select(pair, name, value)

# Perform Kuiper test using only small distances
df_inter_small <- mclapply(df_inter$pair, function (ta) {
  # Get distances
  d1 <- df_inter_dist_small %>% filter(pair == ta) %>% filter(name == "dist") %>% pull(value) # plankton
  d2 <- df_inter_dist_small %>% filter(pair == ta) %>% filter(name == "dist_rand") %>% pull(value) # null
  
  # Number of distances
  n_dist_small <- (length(d1) + length(d2)) / 2
  
  # Kuiper test
  kt <- kuiper_test(d1, d2)
  
  # Return results
  return(
    tibble(
    pair = ta,
    prop_dist_small = n_dist_small / 10000, # proportion of small distances based on the quantiles
    test_stat = kt[1],
    p_value = kt[2]
  ))
  
}, mc.cores = n_cores) %>% 
  bind_rows()

# compute number of small distances based on proportion of small distances and the total number of distances
df_inter_small <- df_inter %>% 
  select(pair, n_dist) %>% 
  left_join(df_inter_small, by = join_by(pair)) %>% 
  mutate(
    n_dist_small = round(n_dist * prop_dist_small), # total number of small distances
    log_n_dist_small = log10(n_dist_small), # log transform number of small distances
    log_test_stat = log10(test_stat) # log transform test stat
  ) %>% 
  filter(n_dist_small > 100) # keep only pairs with at least 100 small distances
```

### Compute mean per pair

```{r mean_pair}
# Compute mean per pair
df_inter_small <- df_inter_small %>% 
  separate_wider_delim(pair, delim = " - ", names = c("p1", "p2"), cols_remove = FALSE) %>% 
  mutate(
    pair_unsrt = ifelse(
      p1 < p2,
      paste(p1, p2, sep = " - "),
      paste(p2, p1, sep = " - ")
    ), .after = pair
  )

# Compute average of stats per pair
df_inter_small <- df_inter_small %>% 
  select(pair = pair_unsrt, n_dist:log_test_stat) %>% 
  group_by(pair) %>% 
  summarise_if(is.numeric, mean)
```

### Detect pairs above the ribbon

```{r detect_above}
# Detect taxa which are above the ribbon and have enough distances
df_inter_small <- df_inter_small %>% 
  mutate(
    above = log_test_stat > log_n_dist_small * (rq_coef %>% filter(tau == 0.95) %>% pull(slope)) + (rq_coef %>% filter(tau == 0.95) %>% pull(intercept)), # above the ribbon
    keep = n_dist_small > n_dist_min, # enough distances
    above = above & keep # combination of both
    ) %>% 
  select(-keep)
df_inter_small_above <- df_inter_small %>% filter(above)
```

## Results

### Kuiper statistic VS number of distances

Plot Kuiper statistic VS number of distances.

```{r kuiper_plot}
#| fig-column: body-outset
#| out-width: 100%
# With all taxa
ggplot() + 
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray") +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter_small, aes(x = log_n_dist_small, y = log_test_stat), alpha = 0.5, size = 0.5) +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force), breaks = seq(2, 8, by = 2)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic", colour = "Pair", fill = "Pair", shape = "Pair") 

# With only taxa above ribbon
# Highligh pairs with Acantharea
ggplot() +
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray", outlier.shape = NA) +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter_small %>% filter(above), aes(x = log_n_dist_small, y = log_test_stat, colour = str_detect(pair, "Acantharea")), alpha = 0.5, size = 0.5) +
  geom_point(data = df_inter_small %>% filter(!above), aes(x = log_n_dist_small, y = log_test_stat), colour = "gray", size = 0.5) +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force), breaks = seq(2, 8, by = 2)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic", colour = "Acantharea") 
```

### Distribution of distances

Plot distribution of distances.

```{r dist}
#| fig-column: body-outset
#| out-width: 100%
# Plot density for 20 random pairs
pairs_to_plot <- sample(df_inter_small_above$pair, size = 20)
df_inter_dist_small %>% 
  filter(pair %in% pairs_to_plot) %>% 
  ggplot() +
  geom_density(aes(x = value, colour = name), linewidth = 0.3) +
  scale_colour_manual(
    values = c("dist_rand" = "grey60", "dist" = "black"),
    labels = c("plankton", "null")
    ) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type") +
  facet_wrap(~pair, scales = "free") +
  theme(strip.text = element_text(size = 6))
```

Plot ECDF.

```{r ecdf}
#| fig-column: body-outset
#| out-width: 100%
# Plot ECDF
df_inter_dist_small %>% 
  filter(pair %in% pairs_to_plot) %>% 
  ggplot() +
  stat_ecdf(aes(x = value, colour = name), linewidth = 0.3) +
  scale_colour_manual(
    values = c("dist_rand" = "grey60", "dist" = "black"),
    labels = c("plankton", "null")
    ) +
  facet_wrap(~pair, scales = "free") +
  theme(strip.text = element_text(size = 6))
```

### Direction of interaction

```{r check_dir}
#| fig-column: body-outset
#| out-width: 100%
# Reshape df to have one row per pair
df_wide <- df_inter_dist_small %>% 
  filter(pair %in% df_inter_small_above$pair) %>% 
  pivot_wider(names_from = "name", values_from = "value", values_fn = list)

# Loop over taxa
ecdfs <- lapply(1:nrow(df_wide), function(i) {
  # Get row
  r <- df_wide %>% slice(i)  
  
  # Compute ecdf
  # Needs a nested call: ecdf(x) returns a function, x being the values of interest
  # Call this function with argument x2 to get values along x2 (here, plankton distances so that we have a common x axis) 
  plank_ecdf <- ecdf(unlist(r$dist))(unlist(r$dist))
  null_ecdf <- ecdf(unlist(r$dist_rand))(unlist(r$dist))
  
  # Return difference
  res <- tibble(
    plank_dist = sort(unlist(r$dist)),
    plank_ecdf = plank_ecdf,
    null_ecdf = null_ecdf,
    diff = plank_ecdf - null_ecdf
    ) %>% 
    mutate(pair = r$pair) %>% # add pair
    select(pair, everything())
  return(res)
}) %>% 
  bind_rows()

# Plot the result for a few pairs
ecdfs %>% 
  filter(pair %in% pairs_to_plot) %>%
  ggplot() + 
  geom_hline(yintercept = 0, colour = "gray60", linewidth = 0.3) +
  geom_path(aes(x = plank_dist, y = diff), linewidth = 0.3) +
  facet_wrap(~pair, scales = "free") +
  labs(x = "Distance (cm)", y = "Plankton ECDF - Null ECDF") +
  theme(strip.text = element_text(size = 6))

# To get a summary, we can sum the differences for each pair.
ecdfs_dir <- ecdfs %>% 
  group_by(pair) %>% 
  summarise(diff = sum(diff)) %>% # sum differences between ECDFs
  mutate(dir = ifelse(sign(diff) == 1, "closer", "further")) %>% # flag the direction of the interaction
  left_join(df_inter_small %>% select(pair, n_dist_small), by = join_by(pair)) %>% 
  # drop Collodaria_colonial
  filter(!str_detect(pair, "Collodaria_colonial")) %>% 
  arrange(diff) %>% 
  mutate(pair = fct_inorder(pair))

# Store this with pairs information
df_inter_small <- df_inter_small %>% left_join(ecdfs_dir, by = join_by(pair, n_dist_small))

# Plot the distribution of differences
ggplot(ecdfs_dir) + geom_density(aes(x = diff))
# Most differences are positive, i.e. distances are shorter than expected under a random distribution of organisms

# Look at the relationship between the difference in ECDFs and the number of distances
ggplot(ecdfs_dir) + 
  geom_point(aes(x = n_dist_small, y = diff, colour = dir), size = 0.5) +
  scale_colour_manual(values = c("#67a9cf", "#ef8a62")) +
  scale_x_continuous(trans = "log10") +
  labs(x = "Number of distances", y = "Sum of differences between plankton ECDF and null ECDF", colour = "Direction")

# Plot for a few pairs
ecdfs_dir %>% 
  filter(pair %in% pairs_to_plot) %>% 
  ggplot() +
  geom_col(aes(y = pair, x = diff, fill = dir)) +
  scale_fill_manual(values = c("#67a9cf", "#ef8a62")) +
  labs(x = "Sum of differences between plankton ECDF and null ECDF", y = "pair", fill = "Direction")

# Kuiper statistic VS number of distances, with interaction direction
ggplot() +
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray", outlier.shape = NA) +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter_small %>% filter(above), aes(x = log_n_dist_small, y = log_test_stat, colour = dir), size = 0.5) +
  scale_colour_manual(values = c("#67a9cf", "#ef8a62")) +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force), breaks = seq(2, 8, by = 2)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic", colour = "Direction") 
```

Let’s plot a few more specific examples, taking the more negative differences (i.e. longer distances).

```{r plot_longer}
ecdfs %>% 
  filter(pair %in% ecdfs_dir$pair[1:4]) %>%
  add_count(pair) %>% 
  mutate(lab_pair = paste0(pair, " (n = ", n, ")")) %>% 
  ggplot() + 
  geom_hline(yintercept = 0, colour = "gray60", linewidth = 0.3) +
  geom_path(aes(x = plank_dist, y = diff), linewidth = 0.3) +
  facet_wrap(~lab_pair, scales = "free") +
  labs(x = "Distance (cm)", y = "Plankton ECDF - Null ECDF")
```

### Interaction strength & confidence

```{r z_scores}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 5

df_inter_scores <- df_inter_small %>% 
  mutate(
    # compute estimated mean, 5th and 95th percentiles kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist_small + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymean = rq_coef %>% filter(tau == "mean") %>% pull(slope) * log_n_dist_small + rq_coef %>% filter(tau == "mean") %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist_small + rq_coef %>% filter(tau == 0.95) %>% pull(intercept),
    # compute sigma
    sigma = (ymax - ymin) / (2 * 1.645),
    # compute z-score
    z_score = (log_test_stat - ymean)/sigma
  )

ggplot() +
  geom_boxplot(data = f_val_dist, aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray", outlier.shape = NA) +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_point(data = df_inter_scores %>% filter(above), aes(x = log_n_dist_small, y = log_test_stat, colour = z_score), size = 0.5) +
  scale_colour_viridis_c() +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force), breaks = seq(2, 8, by = 2)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic", colour = "Z-score") 
```

Plot Z-score VS Kuiper statistic.

```{r plot_z}
#| fig-column: body-outset
#| out-width: 100%
#| fig-width: 8
#| fig-height: 5
ggplot(df_inter_scores) + 
  geom_point(aes(x = test_stat, y = z_score, colour = dir), size = 0.5) +
  scale_colour_manual(values = c("#67a9cf", "#ef8a62")) +
  labs(x = "Kuiper statistic", y = "Z-score", colour = "Direction") +
  expand_limits(x = 0, y = 0) +
  xlim(c(0, 0.05))
```

::: {.callout-note icon="false"}
## Conclusion

**When focusing on small distances only, we detect more taxa for which the distribution of distances differs from those expected under a random distribution of organisms.**
:::

## Save

Save Z-score and Kuiper stat.

```{r save}
#save(df_inter_scores, df_inter_dist_small, file = "data/05c.df_inter_scores_small.Rdata")
```
