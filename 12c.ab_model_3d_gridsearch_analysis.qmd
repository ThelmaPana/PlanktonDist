---
title: "Results of the gridsearch for the agent based model simulating plankton displacement"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: false
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
source("utils_ab_model.R")
```

## Load data

```{r load}
#| cache: false

# Simulation results
sim_res <- read_parquet("data/12b.simulation_results_gridsearch.parquet")

# Keep only distances below threshold
sim_res <- sim_res %>% filter(dist < dist_thr)

# Drop technical model parameters
sim_res <- sim_res %>% select(-c(d_length_px, prop_mv, h))

# Kuiper stat for null dataset
load("data/04b.null_ks.Rdata")

# Read plankton distances
plank_dist <- read_parquet("data/distances/02a.all_distances_plankton.parquet") %>% 
  filter(dist < dist_thr) # filter distances using threshold

# Read null distances
rand_dist <- read_parquet("data/distances/02a.all_distances_random.parquet") %>% 
  filter(dist < dist_thr) # filter distances using threshold

# Get quantiles for both
plank_qt <- quantile(plank_dist$dist, probs = probs, names = FALSE)
rand_qt <- quantile(rand_dist$dist, probs = probs, names = FALSE)
```

## Model results

### Process model results

For each set of parameters, extract 10000 quantiles and compute Kuiper stat.

```{r process_sim_res}
sim_res_ks <- sim_res %>%
  select(-c(p1, p2)) %>%
  # group by parameter set
  group_by(d_length_cm, sr) %>%
  group_modify(~ {
    dist_after <- .x %>% filter(when == "after") %>% pull(dist) # get distances after
    dist_before <- .x %>% filter(when == "before") %>% pull(dist) # get distances before
    
    # Number of distances after and before
    n_dist_after <- length(dist_after)
    n_dist_before <- length(dist_before)
    
    # Get 10000 quantiles if needed
    if (n_dist_after > 10000) {
      dist_after <- quantile(dist_after, probs = probs, names = FALSE)
    }
    if (n_dist_before > 10000) {
      dist_before <- quantile(dist_before, probs = probs, names = FALSE)
    }

    # Compute Kuiper stat
    kt <- kuiper_stat(dist_before, dist_after)
    
    # Return results
    tibble(
      n_dist_after = n_dist_after,
      n_dist_before = n_dist_before,
      n_dist = (n_dist_after + n_dist_before) / 2,
      log_n_dist = log10(n_dist),
      kuiper_stat = kt,
      log_kuiper_stat = log10(kuiper_stat),
      dist_before_qt = list(dist_before),
      dist_after_qt = list(dist_after)
    )
  }) %>% 
  ungroup()

# Keep one table with distances
sim_res_dist <- sim_res_ks %>% 
  select(d_length_cm, sr, dist_before_qt, dist_after_qt) %>% 
  unnest(c(dist_before_qt, dist_after_qt)) %>% 
  pivot_longer(dist_before_qt:dist_after_qt, names_to = "when", values_to = "dist") %>% 
  mutate(when = ifelse(str_detect(when, "before"), "before", "after"))

# And one without distances
sim_res_ks <- sim_res_ks %>% select(-c(dist_before_qt, dist_after_qt))
```

### Distances for each parameter set

Let’s now have a look at the model results for the different set of parameters.

```{r plot_dist}
#| fig-column: body-outset
#| out-width: 100%
#| fig-height: 5
## Plot distances
ggplot(sim_res_dist) +
  geom_density(aes(x = dist, colour = when)) +
    scale_colour_manual(values = c("#00B2FF", "grey")) +
  labs(x = "Distance (cm)", y = "Density", colour = "When") +
  theme_classic() +
  facet_grid(d_length_cm~sr, labeller = labeller(.rows = label_both, .cols = label_both))

```

Let’s also plot ECDFs.

```{r plot_ecdf}
#| fig-column: body-outset
#| out-width: 100%
#| fig-height: 5
ggplot(sim_res_dist) +
  stat_ecdf(aes(x = dist, colour = when)) +
  scale_colour_manual(values = c("#00B2FF", "grey")) +
  labs(x = "Distance (cm)", y = "Density", colour = "When") +
  theme_classic() +
  facet_grid(d_length_cm~sr, labeller = labeller(.rows = label_both, .cols = label_both))
```

We clearly see that the choice of parameter affects the distribution of distances after displacement. Let’s plot Kuiper statistic for each set of parameters.

## Compare model with observations

To find the best model, i.e. the one that reproduces best the observed distances, let’s compute the Kuiper statistic between each model and observations, and select the model with the lowest value.

```{r mod_vs_obs_ks}
#| fig-column: body-outset
#| out-width: 100%

# Subsample 300,000 observations
plank_dist_sub <- plank_dist %>% slice_sample(n = 300000)
rand_dist_sub <- rand_dist %>% slice_sample(n = 300000)

# Get observations quantiles
plank_dist_sub_qt <- quantile(plank_dist_sub$dist, probs = probs, names = FALSE)
rand_dist_sub_qt <- quantile(rand_dist_sub$dist, probs = probs, names = FALSE)

# For each set of parameters, compute Kuiper stat between model and observations
sim_vs_obs_ks <- sim_res %>%
  select(-c(p1, p2)) %>%
  # group by parameter set
  group_by(d_length_cm, sr) %>%
  group_modify(~ {
    # Get model distances after displacement
    dist_mod <- .x %>% filter(when == "after") %>% pull(dist) 
    
    # Number of distances after and before
    n_dist_mod <- length(dist_mod)
    
    # Get 10000 quantiles if needed
    if (n_dist_mod > 10000) {
      dist_mod <- quantile(dist_mod, probs = probs, names = FALSE)
    }

    # Compute Kuiper stat between model and observations
    kt <- kuiper_stat(dist_mod, plank_dist_sub_qt)
    
    # Return results
    tibble(
      n_dist_mod = n_dist_mod,
      n_dist_obs = 300000,
      n_dist = (n_dist_mod + n_dist_obs) / 2,
      log_n_dist = log10(n_dist),
      kuiper_stat = kt,
      log_kuiper_stat = log10(kuiper_stat),
      dist_mod_qt = list(dist_mod),
      dist_obs_qt = list(plank_dist_sub_qt)
    )
  }) %>% 
  ungroup() %>% 
  arrange(kuiper_stat)

```

Plot Kuiper stat value between model and observations.

```{r plot_ks_mod_obs}
#| fig-column: body-outset
#| out-width: 100%

sim_vs_obs_ks %>% 
  arrange(d_length_cm, sr) %>% 
  mutate(set = paste0("d_length_cm: ", d_length_cm, "; sr: ", sr) %>% fct_inorder()) %>% # generate label for set, ordered by Kuiper stat values 
  select(set, kuiper_stat, dist_mod_qt, dist_obs_qt) %>% 
  unnest(c(dist_mod_qt, dist_obs_qt)) %>% 
  pivot_longer(dist_mod_qt:dist_obs_qt) %>% 
  mutate(name = ifelse(str_detect(name, "mod"), "model", "obs.")) %>% 
  ggplot() +
  geom_density(aes(x = value, linetype = name, colour = kuiper_stat)) +
  scale_colour_viridis_c() +
  labs(x = "Distance (cm)", y = "Density", colour = "Kuiper stat", linetype = "What") +
  theme_classic() +
  facet_wrap(~set) 
```

This is not easy to read, let’s order the models by Kuiper stat values and plot results.

```{r plot_ks_mod_obs_ord}
#| fig-column: body-outset
#| out-width: 100%

sim_vs_obs_ks %>% 
  arrange(kuiper_stat) %>% 
  mutate(rank = row_number() %>% as.factor()) %>% 
  arrange(d_length_cm, sr) %>% 
  mutate(set = paste0("d_length_cm: ", d_length_cm, "; sr: ", sr) %>% fct_inorder()) %>% # generate label for set, ordered by Kuiper stat values 
  select(set, rank, kuiper_stat, dist_mod_qt, dist_obs_qt) %>% 
  unnest(c(dist_mod_qt, dist_obs_qt)) %>% 
  pivot_longer(dist_mod_qt:dist_obs_qt) %>% 
  mutate(name = ifelse(str_detect(name, "mod"), "model", "obs.")) %>% 
  ggplot() +
  geom_density(aes(x = value, linetype = name, colour = rank)) +
  labs(x = "Distance (cm)", y = "Density", colour = "Rank", linetype = "What") +
  theme_classic() +
  facet_wrap(~set)
```

Let’s plot observations VS model for the best model.

```{r plot_mod_obs}
#| fig-column: body-outset
#| out-width: 100%

# Get model distances corresponding to selected set of parameters
mod_dist <- sim_vs_obs_ks %>% 
  arrange(kuiper_stat) %>% 
  slice(1) %>% 
  left_join(sim_res_dist, by = join_by(d_length_cm, sr)) %>% 
  mutate(what = "model")

# Observation distances
obs_dist <- tibble(
  what = "obs",
  when = "before",
  dist = rand_dist_sub_qt
) %>% 
  bind_rows(
    tibble(
      what = "obs",
      when = "after",
      dist = plank_dist_sub_qt
    )
  )

# Bind together
all_dist <- bind_rows(
  mod_dist,
  obs_dist
)

# Plot model and observations for before and after
ggplot(all_dist) +
  geom_density(aes(x = dist, colour = when, linetype = what)) +
  scale_colour_manual(values = c("#00B2FF", "grey")) +
  scale_linetype_manual(values = c("dashed", "solid")) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type", linetype = "From") +
  ggtitle("Best model according to KS between model and observations") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0.001), breaks = c(0, 0.05, 0.10)) +
  theme_classic()
```

## Compare with multiple subsets of observations

Because there is a risk that subsampling 300,000 observations results in non-negligible variability in the chosen model, let’s compare the models VS 100 subsamples of the observations. Then, look for the majority model.

```{r comp_mult_obs}
n_sub_obs <- 100 # number of observation subsamples
subsample_size <- 300000 # number of distances in each subsample

# Create chunks and randomly select chunks
sam_plank_dist <- plank_dist %>% 
  mutate(chunk = ntile(1:nrow(.), 440)) %>%  # create chunks 
  filter(chunk %in% sample(1:440, size = n_sub_obs, replace = FALSE)) %>% 
  group_by(chunk) %>% 
  mutate(chunk_id = cur_group_id() %>% as.factor()) %>% 
  ungroup() %>% 
  select(-chunk) %>% 
  select(chunk = chunk_id, everything())

# Precompute quantiles for each chunk of observation data
sam_plank_dist_gr <- sam_plank_dist %>%
  group_by(chunk) %>%
  summarize(
    dist_obs_qt = list(quantile(dist, probs = probs, names = FALSE))
  ) %>%
  ungroup()

# Compute kuiper stat between each set of parameters and observations
sim_vs_obs_dist_mult_ks <- sim_res %>%
  select(-c(p1, p2)) %>%
  # Group by parameter set (d_length_cm, sr)
  group_by(d_length_cm, sr) %>%
  group_modify(~ {
    # Extract distances for the model
    dist_mod <- .x %>% filter(when == "after") %>% pull(dist)
    n_dist_mod <- length(dist_mod)
    
    # Compute quantiles for model distances
    dist_mod_qt <- quantile(dist_mod, probs = probs, names = FALSE)
    
    # Process each observation chunk and compute the Kuiper stat
    res <- sam_plank_dist_gr %>%
      #slice(1) %>% 
      rowwise() %>%
      mutate(
        kuiper_stat = kuiper_stat(dist_mod_qt, unlist(dist_obs_qt)) # Compute Kuiper stat between model and observed quantiles
      ) %>%
      ungroup() %>%
      mutate(
        n_dist_mod = n_dist_mod,           # Number of modelled distances
        n_dist_obs = subsample_size,       # Number of observed distances
        n_dist = (n_dist_mod + n_dist_obs) / 2
      ) %>% 
      select(-dist_obs_qt)
    
    return(res)
  }) %>% 
  bind_rows() %>% 
  ungroup()


```

For each observation resample, find the best model, and count how many times each set of parameters is selected as the best model.

```{r count_best}
best_mods <- sim_vs_obs_dist_mult_ks %>% 
  group_by(chunk) %>% 
  filter(kuiper_stat == min(kuiper_stat)) %>% 
  ungroup() %>% 
  # model parameters as factors for plotting, with levels as full range of possible params
  mutate(
    d_length_cm = factor(d_length_cm, levels = unique(sim_res$d_length_cm)),
    sr = factor(sr, levels = unique(sim_res$sr))
  )

ggplot(best_mods) +
  geom_count(aes(x = sr, y = d_length_cm, color = after_stat(n), size = after_stat(n))) +
  scale_colour_viridis_c() +
  scale_y_discrete(drop = F) +
  labs(x = "Sensory radius (cm)", y = "Displacement length (cm)") +
  guides(color = 'legend') +
  theme_classic()

# Extract the winning model
best_mod <- best_mods %>% count(d_length_cm, sr) %>% arrange(desc(n)) %>% slice(1)
```

Let’s now replot modeled distances VS all observations.

```{r plot_best_sim}
#| fig-column: body-outset
#| out-width: 100%
#| cache: false

# Get results of the best model
best_sim <- best_mod %>%
  select(-n) %>% 
  mutate(
    d_length_cm = d_length_cm %>% as.character() %>% as.numeric(),
    sr = sr %>% as.character() %>% as.numeric()
    ) %>% 
  left_join(sim_res, by = join_by(d_length_cm, sr))

# Extract model quantiles
sim_qt <- best_sim %>% 
  group_by(when) %>% 
  reframe(qt = quantile(dist, probs = probs, names = FALSE)) %>% 
  mutate(what = factor("model")) %>% 
  select(when, what, qt)

# Extract observations quantiles
obs_qt <- bind_rows(
  tibble(qt = plank_qt, when = "after"),
  tibble(qt = rand_qt, when = "before")  
) %>% 
  mutate(
    when = as.factor(when),
    what = factor("obs")
    )

# Store everything together
all_qt <- bind_rows(obs_qt, sim_qt)
ggplot(all_qt) +
  geom_density(aes(x = qt, colour = when, linetype = what)) +
  scale_colour_manual(values = c("#00B2FF", "grey")) +
  scale_linetype_manual(values = c("dashed", "solid")) +
  labs(x = "Distance (cm)", y = "Density", colour = "Type", linetype = "From") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0.001), breaks = c(0, 0.05, 0.10)) +
  theme_classic()
```
