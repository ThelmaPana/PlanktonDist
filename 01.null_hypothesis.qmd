---
title: "Generate random data for our null hypothesis"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: false
  freeze: false
---

```{r set_up}
#| echo: false
source("utils.R")
```

```{r read}
#| cache.lazy: True
## All data
images <- read_parquet("data/00.images_clean.parquet")
plankton <- read_parquet("data/00.plankton_clean.parquet")

# list img names
img_names <- sort(unique(images$img_name))
```

Define window size for point pattern analysis.

```{r vol_size}
# image volume in pixels
vol <- c()
vol$x <- 10240
vol$y <- 2048
vol$z <- 9572
```

**Null hypothesis: plankton is randomly distributed**. This hypothesis can easily be generated by generating a set of images in which we draw random points. Regarding the number of points to draw within each image, we can have a look at the number of objects per image, fit a law, and sample this law.

## Number of objects per image

```{r count_obj}
# Number of objects per image
counts <- plankton %>% count(img_name)
ggplot(counts) + geom_histogram(aes(x = n), bins = 100)
```

This looks like a lognormal law, let’s try fitting this. Then, we can draw a given number of images from this law (e.g. `n_img = 1000`) and this will give us a number of objects within each image that is representative of the dataset. Still, we need to round the number of objects.

```{r fit_law}
#| warning: false

# Fit a lognormal law
fit_params <- fitdistr(counts$n,"lognormal")

# Sample the law
n_img <- 1000
sample <- tibble(
  n = rlnorm(n_img, fit_params$estimate['meanlog'], fit_params$estimate['sdlog'])
  ) %>% 
  mutate(n = round(n)) # round number of objects

# Plot samples from fitted law VS data, focusing on relatively low values
ggplot() + 
  geom_histogram(data = counts, aes(x = n), stat = "density") +
  geom_density(data = sample, aes(x = n), colour = "red") +
  xlim(0, 200)
```

## Distances between random objects

Generate our random data.

```{r pick_rand}
# Pick random points within image volumes
rand_points <- mclapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- sample$n[i]
  # Draw points
  d_points <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
}, mc.cores = n_cores)

# Store this in a df
rand_points <- do.call(bind_rows, rand_points)

```

Compute and plot distances between all objects within each image.

```{r rand_dist}
# Loop over images and compute distances between all points within each image
dist_all_rand <- mclapply(unique(rand_points$img_name), function(name) {
  # Get points within image
  points <- rand_points %>% 
    filter(img_name == name) %>% 
    select(x, y) %>% 
    as.matrix()
  # Compute distances between points
  melt(as.matrix(dist(points)), varnames = c("p1", "p2")) %>% 
    as_tibble() %>% 
    filter(p1 != p2) %>% 
    rename(dist = value) %>% 
    mutate(img_name = name) %>% 
    # Keep only one of distances compute between A and B (A to B and B to A were computed)
    mutate(pair = paste0(p1, p2)) %>% 
    mutate(pair = vapply(strsplit(pair, NULL), function(x) paste(sort(x), collapse = ''), '')) %>%
    distinct(img_name, pair, dist, .keep_all = TRUE) %>% 
    select(-pair)
}, mc.cores = n_cores)

# Combine results in a dataframe
dist_all_rand <- do.call(bind_rows, dist_all_rand)

# Check that we have the number of expected distances within each image
# For a set of n points, the number of unique distances is n(n-1)/2
dist_ok <- left_join(
    rand_points %>% count(img_name, name = "n_obj"),
    dist_all_rand %>% count(img_name, name = "n_dist"),
    by = join_by(img_name)
  ) %>% 
  mutate(ok = n_dist == (n_obj * (n_obj-1))/2)

all(dist_ok$ok) # should return TRUE


# Plot all
ggplot(dist_all_rand) + 
  geom_density(aes(x = dist, group = img_name), alpha = 0.1, linewidth = 0.02, colour = "dodgerblue") +
  geom_density(aes(x = dist))

ggplot(dist_all_rand) + 
  geom_density(aes(x = dist)) +
  labs(title = "Density distribution of distances for a random distribution")

# Save it
save(dist_all_rand, rand_points, file = "data/01.null_data.Rdata")
```
