---
title: "Generate random data for our null hypothesis"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
```

```{r read}
#| cache.lazy: false
## All data
images <- read_parquet("data/00.images_clean.parquet")
plankton <- read_parquet("data/00.plankton_clean.parquet")

# list img names
img_names <- sort(unique(images$img_name))
```

Define window size for point pattern analysis.

```{r vol_size}
# image volume in pixels
vol <- c()
vol$x <- 10240
vol$y <- 2048
vol$z <- 9572
```

**Null hypothesis: plankton is randomly distributed**. This hypothesis can easily be generated by generating a set of images in which we draw random points. Regarding the number of points to draw within each image, we can have a look at the number of objects per image, fit a law, and sample this law.

## Number of objects per image

```{r count_obj}
# Number of objects per image
counts <- plankton %>% count(img_name)
ggplot(counts) + geom_histogram(aes(x = n), bins = 100)
```

This looks like a lognormal law, let’s try fitting this. Then, we can draw a given number of images from this law (e.g. `n_img = 1000`) and this will give us a number of objects within each image that is representative of the dataset. Still, we need to round the number of objects.

```{r fit_law}
#| warning: false

# Fit a lognormal law
fit_params <- fitdistr(counts$n,"lognormal")

# Sample the law
n_img <- 1000
sample <- tibble(
  n = rlnorm(n_img, fit_params$estimate['meanlog'], fit_params$estimate['sdlog'])
  ) %>% 
  mutate(n = round(n)) # round number of objects

# Plot samples from fitted law VS data, focusing on relatively low values
ggplot() + 
  geom_histogram(data = counts, aes(x = n), stat = "density") +
  geom_density(data = sample, aes(x = n), colour = "red") +
  xlim(0, 200)
```

## Distances between random objects

Generate our random data.

```{r pick_rand}
# Pick random points within image volumes
rand_points <- mclapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- sample$n[i]
  # Draw points
  d_points <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
}, mc.cores = n_cores)

# Store this in a df
rand_points <- do.call(bind_rows, rand_points)

```

Compute and plot distances between all objects within each image.

```{r rand_dist}
# Loop over images and compute distances between all points within each image
dist_all_rand <- compute_all_dist(rand_points, n_cores = n_cores)

# Plot all
ggplot(dist_all_rand) + 
  geom_density(aes(x = dist, group = img_name), alpha = 0.1, linewidth = 0.02, colour = "dodgerblue") +
  geom_density(aes(x = dist))

ggplot(dist_all_rand) + 
  geom_density(aes(x = dist)) +
  labs(title = "Density distribution of distances for a random distribution")

# Save it
save(dist_all_rand, rand_points, file = "data/01.null_data.Rdata")
```
