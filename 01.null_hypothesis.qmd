---
title: "Generate random data for our null hypothesis"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
```

```{r read}
#| cache.lazy: false

## Subsampling
if (sub_sample){
  load("data/00.images_sub.Rdata")
  load("data/00.plankton_sub.Rdata")
  images <- images_sub
  plankton <- plankton_sub
} else {
  ## All data
  images <- read_parquet("data/00.images_clean.parquet")
  plankton <- read_parquet("data/00.plankton_clean.parquet")
}

# list img names
img_names <- sort(unique(images$img_name))

```

Define window size for point pattern analysis (done in `utils.R`).

```{r vol_size}
print(vol)
```

**Null hypothesis: plankton is randomly distributed**. This hypothesis can easily be generated by generating a set of images in which we draw random points. Regarding the number of points to draw within each image, we can have a look at the number of objects per image, fit a law, and sample this law.

## Number of objects per image

```{r count_obj}
# Number of objects per image
counts <- plankton %>% count(img_name)
ggplot(counts) + geom_histogram(aes(x = n), bins = 100)
```

Let’s generate `r n_img` images with a similar distribution of number of objects per image.

```{r n_pts}
n_pts <- counts %>% slice_sample(n = n_img, replace = TRUE) %>% pull(n)
```

## Distances between random objects

Generate our random data.

```{r pick_rand}
set.seed(seed)
# Pick random points within image volumes
rand_points <- mclapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- n_pts[i]
  # Draw points
  d_points <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
}, mc.cores = n_cores) %>% 
  bind_rows()
```

Compute and plot distances between all objects within each image.

```{r rand_dist}
#| output: false 
# Loop over images and compute distances between all points within each image
dist_all_rand <- compute_all_dist(rand_points, n_cores = n_cores)

# Save it
save(dist_all_rand, rand_points, file = "data/01.null_data.Rdata")
```

```{r plot_rand_dist}
# Plot all
ggplot(dist_all_rand) + 
  geom_density(aes(x = dist)) +
  labs(title = "Density distribution of distances for a random distribution")
```

## Check that two independent sets of null data return the same results.

```{r two_sets}
#| output: false 
# Pick random points within image volumes
set.seed(seed + 1)
set_1 <- mclapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- n_pts[i]
  # Draw points
  d_points <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
}, mc.cores = n_cores) %>% 
  bind_rows()

# Pick random points within image volumes
set.seed(seed + 2)
set_2 <- mclapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- n_pts[i]
  # Draw points
  d_points <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
}, mc.cores = n_cores) %>% 
  bind_rows()


## Compute distances
dist_1 <- compute_all_dist(set_1, n_cores = n_cores)
dist_2 <- compute_all_dist(set_2, n_cores = n_cores)
```

```{r two_sets_plot}
sets <- bind_rows(
  dist_1 %>% mutate(set = "1"),
  dist_2 %>% mutate(set = "2")
) 

sets %>% 
  ggplot() +
  geom_density(aes(x = dist, colour = set)) +
  labs(title = "Density distribution of distances for two random distributions")
```

```{r two_set_comp}
# Extract 10000-quantiles to perform comparison
probs <- seq(0, 1, length.out = 10000)
dist_1 <- quantile(dist_1$dist, probs = probs, names = FALSE)
dist_2 <- quantile(dist_2$dist, probs = probs, names = FALSE)

tibble(dist = dist_1, set = "1") %>% 
  bind_rows(tibble(dist = dist_2, set = "2")) %>%   
  ggplot(aes(dist, colour = set)) +
  stat_ecdf(geom = "step")

kuiper_test(dist_1, dist_2)
```
