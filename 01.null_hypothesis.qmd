---
title: "Generate random data for our null hypothesis"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: false
  freeze: false
---

```{r set_up}
#| echo: false
source("utils.R")
```

Subsample data (only performed once).

```{r read}
## All data
images <- read_parquet("data/00.images_clean.parquet")
plankton <- read_parquet("data/00.plankton_clean.parquet")

# list img names
img_names <- sort(unique(images$img_name))
```

Define window size for point pattern analysis.

```{r vol_size}
# image volume in pixels
vol <- c()
vol$x <- 10240
vol$y <- 2048
vol$z <- 9572
```

**Null hypothesis: plankton is randomly distributed**. This hypothesis can easily be generated by generating a set of images in which we draw random points. Regarding the number of points to draw within each image, we can have a look at the number of objects per image, fit a law, and sample this law.

## Number of objects per image

```{r count_obj}
# Number of objects per image
counts <- plankton %>% count(img_name)
ggplot(counts) + geom_histogram(aes(x = n), bins = 100)
```

This looks like a lognormal law, let’s try fitting this. Then, we can draw a given number of images from this law (e.g. `n_img = 1000`) and this will give us a number of objects within each image that is representative of the dataset. Still, we need to round the number of objects.

```{r fit_law}
#| warning: false

# Fit a lognormal law
fit_params <- fitdistr(counts$n,"lognormal")

# Sample the law
n_img <- 1000
sample <- tibble(
  n = rlnorm(n_img, fit_params$estimate['meanlog'], fit_params$estimate['sdlog'])
  ) %>% 
  mutate(n = round(n)) # round number of objects

# Plot samples from fitted law VS data, focusing on relatively low values
ggplot() + 
  geom_histogram(data = counts, aes(x = n), stat = "density") +
  geom_density(data = sample, aes(x = n), colour = "red") +
  xlim(0, 200)
```

## Distances between random objects

Generate our random data.

```{r pick_rand}
# Pick random points within image volumes
rand_points <- lapply(1:n_img, function(i){
  # Number of points to sample within image
  n <- sample$n[i]
  # Draw points
  toto <- tibble(
    x = runif(n = n, min = 1, max = vol$x),
    y = runif(n = n, min = 1, max = vol$y),
    z = runif(n = n, min = 1, max = vol$z)
  ) %>% # Add information for img name
  mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
})

# Store this in a df
rand_points <- do.call(bind_rows, rand_points)

# Save it
save(rand_points, file = "data/01.null_hypothesis.Rdata")
```

Compute and plot distances between all objects within each image.

```{r rand_dist}
# Loop over images and compute distances between all points within each image
dist_all <- lapply(unique(rand_points$img_name), function(name) {
  # Get points within image
  points <- rand_points %>% 
    filter(img_name == name) %>% 
    select(x, y) %>% 
    as.matrix()
  # Compute distances between points
  melt(as.matrix(dist(points)), varnames = c("p1", "p2")) %>% 
    as_tibble() %>% 
    filter(p1 != p2) %>% 
    mutate(img_name = name)
})

# Combine results in a dataframe
dist_all <- do.call(bind_rows, dist_all)

# Plot all
ggplot(dist_all) + 
  geom_density(aes(x = value, colour = img_name), linewidth = 0.02, show.legend = F) +
  geom_density(aes(x = value))
```

```{r norm}
#| eval: false
ggplot(data.frame(x = c(-4, 4)), aes(x = x)) +
  stat_function(fun = dnorm) +
  theme_void()
```
