---
title: "Error in distances from 3D to 2D"
subtitle: "Investigate whether 2D distances are representative of 3D distances using null hypothesis data."
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
cache: true
---

```{r set_up}
#| echo: false
#| output: false
#| cache: false
source("utils.R")

```

```{r read_data}
#| cache.lazy: false
# Read data
images <- read_parquet("data/00.images_clean.parquet")
plankton <- read_parquet("data/00.plankton_clean.parquet")
load("data/01a.corr_factor.Rdata")

## Count number of objects per image
counts <- plankton %>% count(img_name)

## Apply correction factor in x
vol$x <- vol$x * med_corr
```

## Prepare null images

We draw a set of points within the volume of an ISIIS image. This volume is:

-   52.5 cm width = 10240 px (`x` dimension). Actually, the physical length of the image depends on the towing speed.

-   10.5 cm height = 2048 px (`y` dimension).

-   50 cm depth ≈ 9752 px (`z` dimension, compressed in images).

Generate null data:

-   1000 images

-   number of objects within each image is representative of ISIIS data

-   within each image, objects are randomly distributed in 3D

```{r generate null}
n_img <- 1000 # Number of images to generate
n_sets <- 1 # Number of datasets to generate

# Representative number of objets per images
n_pts <- counts %>% slice_sample(n = n_img, replace = TRUE) %>% pull(n)

# Generate sets of random images
rand_points <- lapply(1:n_sets, function(i_set) {
  message(paste("Generating set", i_set))
  # Pick random points within image volumes
  mclapply(1:n_img, function(i){
    # Number of points to sample within image
    n <- n_pts[i]
    # Draw points
    d_points <- tibble(
      x = runif(n = n, min = 1, max = vol$x),
      y = runif(n = n, min = 1, max = vol$y),
      z = runif(n = n, min = 1, max = vol$z)
    ) %>% # Add information for img name
      mutate(img_name = paste0("img_", str_pad(i, nchar(n_img), pad = "0")))
  }, mc.cores = n_cores) %>% 
    bind_rows()
}) %>% 
  bind_rows() # because lapply returns a list
```

```{r plot_one}
# Pick one image
r_points <- rand_points %>% 
  filter(img_name == "img_0001")

# Plot one image
r_points %>% 
  ggplot() +
  geom_point(aes(x = x, y = y, colour = z)) +
  scale_colour_viridis_c() +
  coord_fixed()
```

## From 2D to 3D?

### Compute all distances in 2D and 3D

```{r comp_dist}
dist_all_2d <- compute_all_dist(rand_points, z_dim = FALSE)
dist_all_3d <- compute_all_dist(rand_points, z_dim = TRUE)
```

### Compare 3D and 2D

We can expect distances in 2D to be 2/3 of distances in 3D. Let’s plot this:

-   black line shows upper bound (distance in 2D cannot be larger than distance in 3D)

-   red line shows the expected 2/3 relationship

-   blue line is a linear fit with `intercept = 0`

```{r 2d_vs_3d}
df <- tibble(
  dist_2D = dist_all_2d$dist,
  dist_3D = dist_all_3d$dist
  ) %>% 
  # convert from px to mm
  mutate(
    dist_2D = dist_2D * 51 / 10000,
    dist_3D = dist_3D * 51 / 10000
  )

df %>% 
  slice_sample(n = 1000) %>% 
  ggplot(aes(x = dist_3D, y = dist_2D)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_abline(slope = 2/3, intercept = 0, colour = "red") +
  geom_point() +
  stat_smooth(method = "lm", formula = "y ~ x + 0") +
  labs(x = "3D distance (cm)", y = "2D distance (cm)")
```

Note too bad! Let’s actually fit the model to get the slope.

```{r mod_2d_3d}
mod <- lm(dist_2D ~ 0 + dist_3D, data = df)
summary(mod)
```

Slope is 0.78, this depends on the shape of the image volume.

Check the correlation.

```{r mod_corr}
cor(df$dist_2D, df$dist_3D, method = "pearson")
```

Good correlation.

::: {.callout-note icon="false"}
## Conclusion

**Use all distances within an image! 3D distance could be computed from 2D distance.**
:::
