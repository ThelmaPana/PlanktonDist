---
title: "Generate random data for null hypothesis"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: false
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
```

::: callout-note
## Aims

1.  See how the distribution of distances between random points look like. This null data is not used for comparison with true distances, representative null datasets are generated on the fly when computing plankton distances.

2.  Check that two null datasets with the same number of images have the same distance distribution.

3.  Assess the effect of the number of distances (& number of images) on the Kuiper test statistic.
:::

```{r read}
#| cache.lazy: false

## Load data
images <- read_parquet("data/00.images_clean.parquet")
plankton <- read_parquet("data/01.x_corrected_plankton_clean.parquet")
load("data/01.corr_factor.Rdata")

# list img names
img_names <- sort(unique(images$img_name))

## Apply correction factor in x
vol$x <- vol$x * med_corr
```

## Distribution of distances between objects if they are randomly distributed.

First, we need to generate a null dataset that is representative of the true dataset in terms of number of objects per image.

### Number of objects per image

```{r count_obj}
# Number of objects per image
counts <- plankton %>% count(img_name)

ggplot(counts) + 
  geom_histogram(aes(x = n), bins = 100) +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "N obj", y = "Count")
```

### Distances between random objects

```{r null_dist}
# Load previously computed null distances
load("data/02a.dist_rand.Rdata")

# Convert pix to cm
dist_rand <- dist_rand %>% mutate(dist = dist * 51 / 10000)

# Plot it
ggplot(dist_rand, aes(x = dist)) + geom_density()
ggplot(dist_rand, aes(x = dist)) + stat_ecdf()
```

## Effect of number of distances on Kuiper test statistic

To investigate the effect on the number of distances on the Kuiper statistic, we generate multiple null distributions and compute pair-wise Kuiper statistics for various number of distances. Ideally, we want as many null datasets as possible, but the maximal number of distances is limited by computation cost. A good compromise is to generate 50/100 of these datasets, with a maximum of 10⁷ distances (\~14,000 images). We can then use a quantile regression (0.05 and 0.95 quantiles) to estimate a range of Kuiper statistics for higher number of distances.

### Load and plot

Null dataset generation, distances computation and pair-wise Kuiper tests are done in `02a.null_datasets.R`. We just need to load the data and plot.

```{r load_plot}
load("data/02a.f_val_dist_small.Rdata")

ggplot(f_val_dist) +
  geom_boxplot(aes(x = n_dist, y = test_stat, group = n_dist), colour = "gray") +
  scale_x_log10() + scale_y_log10() +
  labs(x = "N distances", y = "Kuiper statistic")
```

As expected, the Kuiper statistic decreases with the number of computed distances.

### Quantile regression

Let’s do a quantile regression to estimate Kuiper statistic for larger number of distances.

```{r quant_reg}
# Apply log-transformation
f_val_dist <- f_val_dist %>% 
  mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

# Perform quantile regression on 0.05 and 0.95 quantiles
rq_fit <- rq(log_test_stat ~ log_n_dist, data = f_val_dist, tau = c(0.05, 0.95))
# Perform linear regression -> mean
lm_fit <- lm(log_test_stat ~ log_n_dist, data = f_val_dist)

#  Extract coefficients
rq_coef <- tidy(rq_fit) %>% 
  select(term, estimate, tau) %>% 
  mutate(tau = as.character(tau)) %>% 
  mutate(term = case_when(
    term == "(Intercept)" ~ "intercept",
    term == "log_n_dist" ~ "slope",
  )) %>% 
  pivot_wider(names_from = "term", values_from = estimate)
lm_coef <- tidy(lm_fit) %>% 
  select(term, estimate) %>% 
    mutate(term = case_when(
    term == "(Intercept)" ~ "intercept",
    term == "log_n_dist" ~ "slope",
  )) %>% 
  pivot_wider(names_from = "term", values_from = estimate) %>% 
  mutate(tau = "mean", .before = intercept)

# Store all coef together
rq_coef <- rq_coef %>% 
  bind_rows(lm_coef) %>% 
  mutate(tau = as.factor(tau))

# Save quantile reg coefts
save(rq_coef, file = "data/02b.rq_coef_small.Rdata")

# Generate data to plot a ribbon between the regression lines
lim_dist <- c(5e1, 2e9) # extend of the ribbon in x-axis
rib_data <- tibble(n_dist = lim_dist) %>% 
  mutate(
    # apply log-transformation
    log_n_dist = log10(n_dist),
    # compute estimated kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.95) %>% pull(intercept)
  ) %>% 
  # reformat and reorder to plot a polygon
  pivot_longer(ymin:ymax, values_to = "y") %>% 
  mutate(order = c(1, 2, 4, 3)) %>% 
  arrange(order)


# Plot
ggplot(f_val_dist) +
  geom_boxplot(aes(x = log_n_dist, y = log_test_stat, group = log_n_dist), colour = "gray") +
  geom_polygon(data = rib_data, aes(x = log_n_dist, y = y), alpha = 0.1) +
  geom_abline(data = rq_coef %>% filter(tau != "mean"), aes(slope = slope, intercept = intercept, group = tau), linetype = 3) +
  #geom_abline(data = rq_coef %>% filter(tau == "mean"), aes(slope = slope, intercept = intercept, group = tau), linetype = 2) +
  scale_x_continuous(labels = label_math(expr = 10^.x, format = force), expand = c(0, 0)) +
  scale_y_continuous(labels = label_math(expr = 10^.x, format = force)) +
  labs(x = "N distances", y = "Kuiper statistic")
```
