---
title: "Have a look at the agent-based model parameters"
author: "Thelma Panaïotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| echo: false
#| cache: false
source("utils.R")
source("utils_ab_model.R")
```

## Model parameters

Let’s familiarise ourselves with model parameters:

-   `h`: the bandwidth for computing density

-   `d_length`: the displacement length of organisms (in px)

-   `mv_prop`: the proportion of motile organisms (this one is straightforward)

Let’s take just one image as an example and see the effect of both `h` and `d_length`.

```{r gen_image}
set.seed(seed)
# Generate an image with organisms in 3D and plot it in 2D
df <- tibble(
    x = round(runif(n = 15, min = 1, max = vol$x)),
    y = round(runif(n = 15, min = 1, max = vol$y)),
    z = round(runif(n = 15, min = 1, max = vol$z))
  ) %>% # Add information for img name
    mutate(
      img_name = "img_001",
      id = paste0(str_pad(row_number(), 3, pad = "0"))
    )

ggplot(df) +
  geom_point(aes(x, y, colour = z)) +
  scale_colour_viridis_c() +
  coord_fixed()
```

### Density bandwidth

#### Examples

Let’s compute density with various bandwidth values and plot results.

```{r dens_bandwidth}
# List of bandwidth values to try
h_values <- c(10000, 50000, 100000, 500000)

# Empty list to store plots
plots <- list()

# Compute density for each bandwidth
lapply(1:length(h_values), function(i){
  
  # Get bandwidth value
  h <- h_values[i]
  
  # Compute density
  dens_3d <- calculate_density_3d(df, h = h, vol = vol)
  
  # Extract results
  dens_to_plot <- dens_3d$eval.points %>% 
    as_tibble() %>% 
    mutate(dens = dens_3d$estimate) %>% 
    group_by(x, y) %>% 
    summarise(dens = mean(dens), .groups = "drop") %>% 
    mutate(h = h)
  
  # Plot results and store plot
  plots[[i]] <- ggplot(dens_to_plot) +
    geom_raster(aes(x, y, fill = dens)) +
    geom_point(data = df, aes(x, y), size = 0.5) +
    scale_fill_distiller(palette = "Blues", direction = 1) +
    facet_wrap(~h, ncol = 1, labeller = labeller(.rows = label_both)) +
    coord_fixed()
})
```

Sane values are between `100000` and `400000`.

#### Convert to sensory radius in cm

Let’s translate these `h` values into meaningful sensory radius in centimetres.

Try to find the equivalent sensory radius in cm.

For this we generate an image with only 1 point at the center. We compute density using various bandwidth values and assess the decrease in density when going away from the point.

```{r comp_bandwidth}
# Generate 1 image with 1 central point
df_one <- tibble(x = vol$x / 2, y = vol$y / 2, z = vol$z / 2)
# Plot image
ggplot(df_one) +
  geom_point(aes(x, y), show.legend = F) +
  #scale_colour_gradient(high = "grey90", low = "black") +
  scale_x_continuous(sec.axis = dup_axis(breaks = NULL, name = NULL), limits = c(0, vol$x), expand = c(0, 0), breaks = NULL, name = NULL) +
  scale_y_continuous(sec.axis = dup_axis(breaks = NULL, name = NULL), limits = c(0, vol$y), expand = c(0, 0), breaks = NULL, name = NULL) +
  theme_classic() +
  coord_fixed()

# Compute density for various bandwidth values
h_try <- c(50000, 100000, 200000, 400000, 800000, 1600000)
dens_tries <- lapply(h_try, function(h) {
  # Compute density
  dens_3d <- calculate_density_3d(df_one, h = h, vol = vol)
  
  # Extract results
  dens_to_plot <- dens_3d$eval.points %>% 
    as_tibble() %>% 
    mutate(dens = dens_3d$estimate) %>% 
    group_by(x, y) %>% 
    summarise(dens = mean(dens), .groups = "drop") %>% 
    mutate(h = h)
  
  return(dens_to_plot)
}) %>% 
  bind_rows() %>% 
  mutate(h = as.factor(h))

# Compute average density on x axis
dens_1d <- dens_tries %>% 
  group_by(h, x) %>% 
  summarise(dens = mean(dens)) %>% 
  ungroup()

ggplot(dens_1d) + 
  geom_path(aes(x = x, y = dens, colour = h, group = h)) +
  labs(y = "Density") +
  scale_colour_viridis_d()

# Now let’s plot using the point as a reference
dens_dist <- dens_1d %>% 
  mutate(x_pt = df_one$x) %>% # add reference point 
  filter(x <= x_pt) %>% # keep only densities left of this point
  mutate(
    dist = x_pt - x, # compute distance between point and location of density estimate
    dist = dist * 51 / 10000 # convert from px to cm
    ) %>% 
  select(h, dist, dens) 

ggplot(dens_dist) + 
  geom_path(aes(x = dist, y = dens, colour = h, group = h)) +
  labs(x = "Distance (cm)", y = "Density") +
  scale_colour_viridis_d()
```

Let’s now find the distance after which density is \~null, i.e. the x value for which the AUC is 99% of the total AUC.

```{r auc_dist}
# Distances values  
unique_dist <- dens_dist %>% select(dist) %>% unique()
  
# Compute AUC for each distance value
dist_auc <- lapply(1:nrow(unique_dist), function(i) {
  
  # Get reference distance
  dist_val <- unique_dist %>% slice(i) %>% pull(dist)
  
  # Compute AUC
  res <- dens_dist %>% 
    filter(dist < dist_val) %>% # keep only distances below threshold
    #rename(x = dist, y = dens) %>% 
    group_by(h) %>% # group by density bandwidth
    summarise(auc = bayestestR::auc(x = dist, y = dens)) %>% 
    mutate(dist = dist_val) # store distance
  
  return(res)
}) %>% 
  bind_rows()

# For each case, compute proportion of AUC compared to total AUC for given bandwidth
dist_auc <- dist_auc %>% 
  group_by(h) %>% 
  mutate(auc_prop = auc / max(auc)) %>% 
  ungroup() %>% 
  mutate(h = as.factor(h))

thres <- 0.99 # threshold, i.e. we want the distance for which AUC is 99% of total AUC
ggplot(dist_auc) +
  geom_hline(yintercept = thres, colour = "grey") +
  geom_path(aes(x = dist, y = auc_prop, colour = h, group = h)) +
  scale_colour_viridis_d() +
  labs(x = "Distance (cm)", y = "AUC proportion") +
  theme_classic()

# Extract the corresponding distance
# This represents the sensory radius
dist_auc %>% 
  filter(auc_prop > thres) %>% 
  group_by(h) %>% 
  filter(dist == min(dist)) %>% 
  ungroup() %>% 
  select(h, dist)
```

#### Sensory radius in cm to h values

For our model, we’ll use sensory radius values in cm. Let’s find the relationship between sensory radius in cm and h values.

```{r sens_r}
dist_sens <- dist_auc %>% 
  filter(auc_prop > thres) %>% 
  group_by(h) %>% 
  filter(dist == min(dist)) %>% 
  ungroup() %>% 
  mutate(h = as.numeric(levels(h))[h])

ggplot(dist_sens, aes(x = dist, y = h)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ poly(x, 3, raw = TRUE))
# Looks like an x³ relationship, let’s fit it

# Fit a degree 3 polynom
mod_sr <- lm(h ~ poly(dist, 3, raw = TRUE), dist_sens)
summary(mod_sr)
# Very good fit indeed
tidy(mod_sr)
```

We will use model coefficients later for the conversion.

### Displacement length

```{r d_length}
# List of displacement values to try (in px)
d_length_values <- c(50, 100, 300, 500)
(d_length_values * 51)/10000 # to see equivalent in cm

# Generate random gradients in x, y and z directions for each point
gradient_values <- tibble(
    dx = round(runif(n = 15, min = 0, max = 1)),
    dy = round(runif(n = 15, min = 0, max = 1)),
    dz = round(runif(n = 15, min = 0, max = 1))
  )

new_pts <- lapply(d_length_values, function(d_length) {
  # Move points
  new_df <- move_points(df, gradient_values = gradient_values, d_length = d_length)
  
  # Store d_length
  new_df <- new_df %>% mutate(d_length = d_length)
}) %>% 
  bind_rows()

# Store updated points with original points
all_pts <- crossing( # generate all combinations between d_length_values and original points
  df,
  d_length = d_length_values
) %>% 
  mutate(when = "before") %>% # flag as before 
  bind_rows( # bind with updated points
    new_pts %>% mutate(when = "after") # flagged as after
  ) %>% 
  mutate(when = factor(when, levels = c("before", "after")))

ggplot(all_pts) +
  geom_point(aes(x, y, colour = when), size = 0.5) +
  scale_colour_manual(values = c("#66c2a5", "#fc8d62")) +
  facet_wrap(~d_length, ncol = 1, labeller = labeller(.rows = label_both)) +
  coord_fixed()
```

Let’s stay between `100` and `400` px, i.e. between 0.5 and 2 cm.

### Proportion of motile organisms

This can be inferred from the dataset composition and the swimming ability of each taxonomic group.

```{r motility}
# Load motility + count for each taxon
load("data/00.motility_counts.Rdata")
motility_counts %>% 
  group_by(motility) %>% 
  summarise(n = sum(n)) %>% 
  mutate(prop = n / sum(n))
```

Overall, 96% of organisms in the dataset are motile. The proportion with buoyancy control only is negligible.

## Parameter grid

Let’s generate our parameter grid:

-   sensory radius: `5`, `10` and `20` cm

-   displacement: `1`, `2`, `4` and `8` mm

-   motility rate: `96%`

```{r grid_def}
# Initiate our parameter grid with targeted values
param_grid <- crossing(
  sr = c(5, 10, 20),                   # sensory radius (cm)
  d_length_cm = c(0.1, 0.2, 0.4, 0.8), # displacement length (cm)
  prop_mv = 0.96                       # motility rate
)

# Compute density bandwidth (h) to match sensory radius values
param_grid <- augment(mod_sr, newdata = param_grid %>% rename(dist = sr)) %>% 
  # use fitted model to compute h from sensory radius
  select(sr = dist, h = .fitted, d_length_cm, prop_mv) %>% 
  mutate(h = round(h)) # round value of h

# Convert displacement length from cm to px and round it
param_grid <- param_grid %>% 
  mutate(d_length_px = round((d_length_cm * 10000) / 51), .after = d_length_cm)

# Save grid
save(param_grid, file = "data/12a.parameters_grid.Rdata")
```
