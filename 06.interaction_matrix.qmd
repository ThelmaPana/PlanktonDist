---
title: "Build an interaction matrix."
author: "Thelma Pana√Øotis"
format: 
  html:
    toc: true
    embed-resources: true
editor: visual
lightbox: true
execute:
  warning: false
  cache: true
  freeze: false
---

```{r set_up}
#| cache: false
source("utils.R")
```

## Read saved distances

```{r load}
## Intra distances
# list processed files
processed <- list.files("data", pattern = "04.", full.names = TRUE)

# load data
res <- sapply(processed, function(x) mget(load(x)), simplify = TRUE)

# get summary data (1st line)
df_intra <- res[1,] %>% 
  bind_rows() %>% 
  select(t1 = taxon, t2 = taxon, everything())
  
## Inter distances
# list processed files
processed <- list.files("data", pattern = "05.", full.names = TRUE)

# load data
res <- sapply(processed, function(x) mget(load(x)), simplify = TRUE)

# get summary data (1st line)
df_inter <- res[1,] %>% bind_rows() %>% 
  separate_wider_delim(pair, delim = " - ", names = c("t1", "t2")) 

# List taxonomic groups
taxa <- unique(df_inter$t1)

# Average within pairs for inter
df_inter <- df_inter %>% 
  mutate(pair = ifelse(t1 < t2, paste0(t1, " - ", t2), paste0(t2, " - ", t1)), .before = t1) %>% 
  group_by(pair) %>% 
  summarise_if(is.numeric, mean) %>% 
  separate_wider_delim(pair, delim = " - ", names = c("t1", "t2"), cols_remove = FALSE)
# and generate reverse of t1 / t2
df_inter_bis <- df_inter %>% rename(t2 = t1, t1 = t2)

## Bind together intra and inter
df_all <- df_intra %>% 
  bind_rows(df_inter) %>% 
  bind_rows(df_inter_bis)

## Null distances
load("data/02a.f_val_dist.Rdata")
load("data/02b.rq_coef.Rdata")

## Apply log transformation for plotting
f_val_dist <- f_val_dist %>% 
  mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

df_all <- df_all %>% 
    mutate(
    log_n_dist = log10(n_dist),
    log_test_stat = log10(test_stat)
  )

# Drop colonial collodaria, pb with segmentation
df_all <- df_all %>% filter(!(str_detect(t1, "Collodaria_colonial") | str_detect(t2, "Collodaria_colonial")))

# Detect points above the polygon
df_all <- df_all %>% 
  mutate(above = log_test_stat > log_n_dist * (rq_coef %>% filter(tau == 0.95) %>% pull(slope)) + (rq_coef %>% filter(tau == 0.95) %>% pull(intercept)))

# Compute z-scores
df_all <- df_all %>% 
    mutate(
    # compute estimated mean, 5th and 95th percentiles kuiper-stat from slope and intercept
    ymin = rq_coef %>% filter(tau == 0.05) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.05) %>% pull(intercept),
    ymean = rq_coef %>% filter(tau == "mean") %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == "mean") %>% pull(intercept),
    ymax = rq_coef %>% filter(tau == 0.95) %>% pull(slope) * log_n_dist + rq_coef %>% filter(tau == 0.95) %>% pull(intercept),
    # compute sigma
    sigma = (ymax - ymin) / (2 * 1.645),
    # compute z-score
    z_score = (log_test_stat - ymean)/sigma
  )
```

```{r mat}
df_mat <- crossing(t1 = taxa, t2 = taxa) %>% 
  left_join(df_all %>% select(-pair) %>% filter(above), by = join_by(t1, t2))

ggplot(df_mat) +
  geom_raster(aes(x = t1, y = t2, fill = test_stat, alpha = z_score)) +
  scale_fill_viridis_c(na.value = NA) +
  labs(fill = "Kuiper\nstatistic", alpha = "Z-score") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )


mat <- df_intra %>% 
  select(t1, t2) %>% 
  expand(t1, t2) %>% 
  left_join(df_all %>% filter(above) %>% select(t1, t2, strength = test_stat), by = join_by(t1, t2)) %>% 
  pivot_wider(names_from = t2, values_from = strength) %>% 
  as.data.frame() %>% 
  column_to_rownames("t1") %>% 
  data.matrix()


image(mat)
```
